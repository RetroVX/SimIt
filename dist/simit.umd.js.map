{"version":3,"file":"simit.umd.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/SimIt.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\r\n * @author Conor Irwin <https://github.com/RetroVX> \r\n * @license {@link http://opensource.org/licenses/MIT|MIT License}\r\n * @classdesc\r\n * Simulate keyboard and mouse events in the browser\r\n * @class SimIt\r\n * @version 1.0.0\r\n * @example\r\n * const simit = new SimIt();\r\n * \r\n * simit.click(150, 150);\r\n */\r\nexport default class SimIt {\r\n\r\n    constructor(element) {\r\n\r\n        /**\r\n         * Set the element to simulate keyboard/mouse events on. Defaults to window\r\n         * @name SimIt.element\r\n         */\r\n        this.element = element || window || document;\r\n    }\r\n\r\n\r\n    /**\r\n     * Runs through a sequence of steps in an asynchronous manner.\r\n     * This can be a sequence of any supported keyboard/mouse events and callbacks.\r\n     * @method SimIt.all\r\n     * @async\r\n     * @param {array} sequence - an array of objects containing the steps needed to simulate\r\n     * @param {function} [onStart] - callback function that runs once the sequence is starting\r\n     * @param {function} [onComplete] - callback function that runs once the sequence has completed\r\n     * @example\r\n     * simit.all([\r\n     *     { keydown: 's' },\r\n     *     { keyup: 'i' },\r\n     *     { keypress: 'm' },\r\n     *     { sleep: 1000 },\r\n     *     { keydown: 'i' },\r\n     *     { keydown: 't' }\r\n     * ], onStart, onComplete);\r\n     */\r\n    async all(sequence, onStart, onComplete) {\r\n\r\n        if(onStart === undefined || onStart === null) { onStart = function(){}; }\r\n        if(onComplete === undefined || onComplete === null) { onComplete = function(){}; }\r\n\r\n        onStart(sequence);\r\n\r\n        const length = sequence.length;\r\n        let stepCounter = 0;\r\n\r\n        for(let step of sequence) {\r\n            stepCounter++;\r\n\r\n            await this._checkEvent(step);\r\n\r\n            // sequence has finished\r\n            if(stepCounter === length) {\r\n                onComplete(sequence);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Repeats a simulated event\r\n     * @method SimIt.repeat\r\n     * @async\r\n     * @param {object} step - the step to simulate and repeat\r\n     * @param {number} [amount=1] - how many times should the event be repeated?\r\n     * @param {number} [delay=0] - how big the delay should be inbetween each repeated event\r\n     * @example\r\n     * // click at x 150, y 250, 10 times with a 500ms delay between each click\r\n     * simit.repeat({ click: { x: 150, y: 250 } }, 10, 500);\r\n     */\r\n    async repeat(step, amount, delay) {\r\n        if(amount === undefined || amount === null) { amount = 1; }\r\n        if(delay === undefined || delay === null) { delay = 0; }\r\n\r\n        for(let i = 0; i < amount; i++) {\r\n            await this.sleep(delay);\r\n\r\n            await this._checkEvent(step);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Delays the next step in a sequence by x ms\r\n     * @method SimIt.sleep\r\n     * @param {number} ms - milliseconds to delay by (1000 = 1 second)\r\n     * @example\r\n     * async function Hello() {\r\n     *     await simit.sleep(1000);\r\n     *     console.log('I will run after 1 second');\r\n     * }\r\n     * Hello();\r\n     */\r\n    sleep(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n\r\n    /**\r\n     * Simulates a click event on the selected element or window\r\n     * @method SimIt.click\r\n     * @param {number} x - the clientX position to click\r\n     * @param {number} y - the clientY position to click\r\n     * @example\r\n     * simit.click(150, 250);\r\n     */\r\n    click(x, y) {\r\n        return this.element.dispatchEvent(new MouseEvent('click', {'clientX': x || 0, 'clientY': y || 0}));\r\n    }\r\n\r\n\r\n    /**\r\n     * Simulates the keydown event on the selected element or window\r\n     * @method SimIt.keydown\r\n     * @param {string} key - the key string to simulate\r\n     * @example\r\n     * simit.keydown('a');\r\n     */\r\n    keydown(key) {\r\n        return this.element.dispatchEvent(new KeyboardEvent('keydown', {'key': key || undefined}));\r\n    }\r\n\r\n\r\n    /**\r\n     * Simulates the keyup event on the selected element or window\r\n     * @method SimIt.keyup\r\n     * @param {string} key - the key string to simulate\r\n     * @example\r\n     * simit.keyup('b');\r\n     */\r\n    keyup(key) {\r\n        return this.element.dispatchEvent(new KeyboardEvent('keyup', {'key': key || undefined}));\r\n    }\r\n\r\n\r\n    /**\r\n     * Simulates the keypress event on the selected element or window\r\n     * @method SimIt.keypress\r\n     * @param {string} key - the key string to simulate\r\n     * @example\r\n     * simit.keypress('c');\r\n     */\r\n    keypress(key) {\r\n        return this.element.dispatchEvent(new KeyboardEvent('keypress', {'key': key || undefined}));\r\n    }\r\n\r\n\r\n    /**\r\n     * Set the element to simulate with.\r\n     * This method is chainable with every other method.\r\n     * @method SimIt.setElement\r\n     * @param {HTMLElement} element - the element to simulate with\r\n     * @example\r\n     * const element = document.querySelector('myElement');\r\n     * simit.setElement(element);\r\n     * \r\n     * simit.setElement(element).repeat({ keydown: 't' }, 5);\r\n     */\r\n    setElement(element) {\r\n        this.element = element;\r\n\r\n        return this;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Internal method used during SimIt.all and SimIt.repeat.\r\n     * Checks which type of event is needed and dispatches it.\r\n     * @method SimIt._checkEvent\r\n     * @async\r\n     * @param {object} obj - the step object to check\r\n     */\r\n    async _checkEvent(obj) {\r\n        if(obj.keydown) {\r\n            this.keydown(obj.keydown);\r\n        }\r\n        else if(obj.keyup) {\r\n            this.keyup(obj.keyup);\r\n        }\r\n        else if(obj.keypress) {\r\n            this.keypress(obj.keypress);\r\n        }\r\n        else if(obj.click) {\r\n            this.click(obj.click.x, obj.click.y);\r\n        }\r\n        else if(obj.sleep) {\r\n            await this.sleep(obj.sleep);\r\n        }\r\n        else if(obj.callback) {\r\n            await obj.callback();\r\n        }\r\n        else if(obj.repeat) {\r\n            await this.repeat(obj.repeat.event, obj.repeat.amount, obj.repeat.delay);\r\n        }\r\n    }\r\n}"],"names":["SimIt","constructor","element","window","document","all","sequence","onStart","onComplete","undefined","length","stepCounter","step","_checkEvent","repeat","amount","delay","i","sleep","ms","Promise","resolve","setTimeout","click","x","y","dispatchEvent","MouseEvent","keydown","key","KeyboardEvent","keyup","keypress","setElement","obj","callback","event"],"mappings":"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"}